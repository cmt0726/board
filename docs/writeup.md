This time around our core design, while still utilizing the board class, centered around our DragPanel class. We decided to run the game based around a drag and drop system. So, the players, on their turn, are able to click and drag their die to next set they wish to go to with no need for menus.  Menus are used however, for choosing roles, ranking up, and rehearsal. Initially we had an extra class to initialize the frame but there were difficulties getting the window to set up properly and decided that we did not need the extra step to initialize the window. Because of this we scrapped it from our design. After thorough testing of the function of the game, we concluded that it ran very near how exactly we wanted it to run. Few bugs remained at that point. The most noticeable was a bug where after a player icon is snapped to the spot they have chosen to act, they are still able to move their icon around the scene, though their only options are still to act and rehearse. Given more time we would enact another layer of restriction to movement, similar to what we use for adjacent scenes, to snap the player’s icon back to the spot where the role they have chosen remains.

We made several assumptions from the specifications. We opted to use menus for many of the functions of the game. Our player status display on the side of the board has several buttons that are to be used for the many actions the player can take and are even greyed out and unusable if the player cannot take that action at the current moment. Any window popups for roles to take or rank to acquire appears over the player info, so the player sees it immediately, and has priority over other windows. 

To test the code was functioning we simply played the game. We played the game normally to make sure all the basic functions worked, and actions were easy to follow, then we went through again to see what bugs we could find. Our goal for that was to purposefully do things that you would not normally think to do based on the restrictions of the game and to see what happens as a result of those actions. We spent plenty of time trying to break the game purposefully and found, surprisingly, very little after our first attempt to do so.

The most difficult part of the assignment was trying to get the user’s drag and drop actions to properly function with our already coded player actions. The drag and drop required a lot of keeping track of where each player dice was on the board and what they could do while each action was being performed. Many restrictions and updates needed to be considered when, for example, a player simply moves. Moving needs to keep track of what scenes are and are not adjacent based on the x and y position values on the board, as well as the new range of x and y values that the player is now in to update where the player could move. Deciding to act required that the player would be unable to leave the scene, so the adjacent scenes had to be locked but only until the current scene being acted upon was completed. The hardest part to keep track of was the locations of the roles for the purposes of payout. Setting up the payout required us to keep track of the location values of on card versus off card roles and then pay out the different amounts based on which player was where.

It would be interesting to add to this assignment with the use of animations. Including die rolls for actions, visual payout to each player, or a fancy rank up sparkle. Animations to this would make the game much more engaging to the player. Or another interesting variant would be one with online capability. Letting the players interact with the game based on a server side update system or something similar allowing players to see other player actions in real time.
